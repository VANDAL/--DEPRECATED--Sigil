#! /usr/bin/python
##--------------------------------------------------------------------##
##--- This one just parses the data in my file CLG_DRWTEST          --##
##---                                                              ---##
##---                                           CLG_drw_annotate   ---##
##--- Command line args:    ---##
##--------------------------------------------------------------------##

# /*
#    This file is part of Sigil, a tool for call graph profiling programs.
 
#    Copyright (C) 2012, Siddharth Nilakantan, Drexel University
  
#    This tool is derived from and contains code from Callgrind
#    Copyright (C) 2002-2011, Josef Weidendorfer (Josef.Weidendorfer@gmx.de)
 
#    This tool is also derived from and contains code from Cachegrind
#    Copyright (C) 2002-2011 Nicholas Nethercote (njn@valgrind.org)
 
#    This program is free software; you can redistribute it and/or
#    modify it under the terms of the GNU General Public License as
#    published by the Free Software Foundation; either version 2 of the
#    License, or (at your option) any later version.
 
#    This program is distributed in the hope that it will be useful, but
#    WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    General Public License for more details.
 
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
#    02111-1307, USA.
 
#    The GNU General Public License is contained in the file COPYING.
# */

import sys
import re
import matplotlib.pyplot as plt
import numpy as np

DEF_A_CODE = "None"

#Global variables
printcallees = 0
instrs_total = 0
ops_total = 0
percentofinst = 0
comm = []
comp = []
label = []
MAX_DEPENDENCIES = 10

def usage() :
	print "Usage:"
	print "\t" + sys.argv[0] + " [<file>] [printcallees?=<yes|no>] [percentofinst=<0-100>] [mode=<orig|modif|both>]"
	print "\t Continuing with default options - file: CLG_drwtest, printcallees=no, displaying functions which occupy at least 0.01% of instructions, mode=modif"
	print ""

class dependency_chain : #Incomplete. Not yet used
	
	#The chain should have a chance value and a list of MAX functions
	
	def __init__( self, function_number, funcinst_number, vert_parent_fn, ipcomm=0, ipcomm_uniq=0, opcomm=0, opcomm_uniq=0 ) :
		self.chance = 0
	
class consumerfuncinfo :

	def __init__( self, function_number, funcinst_number, vert_parent_fn, consumed_fn, ipcomm=0, ipcomm_uniq=0, opcomm=0, opcomm_uniq=0 ) :
		self.function_number = function_number #Refers to a particular function
		self.funcinst_number = funcinst_number #Refers to a particular function instance (actually context)
		self.vert_parent_fn = vert_parent_fn  #Points to the parent function whose consumed list that this is a part of.
		self.consumed_fn = consumed_fn
		self.dependency_chain = []
		self.ipcomm = int(ipcomm)
		self.ipcomm_uniq = int(ipcomm_uniq)
		self.opcomm = int(opcomm)
		self.opcomm_uniq = int(opcomm_uniq)
		self.min_dep_calls = 0
		self.max_dep_calls = 0
		self.tot_dep_calls = 0
		self.min_ipcomm_uniq = 0
		self.max_ipcomm_calls = 0
		self.tot_ipcomm_uniq = 0
		self.callee_flag = 0 #If set, when found in the consumed list of function A, it means that this function is in the callee chain of A. If found in the consumerlist of function A, means that function A is in the callee chain of this function.
			
class funcinfo :
	'''Array to store central function info. Also has global link to the 
	* structures of functions who consume from this function.
	* Chunks are allocated on demand, and deallocated at program termination.
	* This can also act as a linked list. This is needed because 
	* contiguous locations in the funcarray are not necessarily used. There may
	* be holes in between. Thus we need to track only the locations which are 
	* used from this list. 
	* Alternatively, an array could be used, but needs to be sized statically
	'''
	funcinsttable = None
	
	def __init__( self, function_number, fn_name=None ) :
		self.function_name = fn_name
		self.function_number = function_number
		self.funcinsttable = {}
		#self.number_of_funcinsts = 0; #Removed because we can always query the length of the variable above instead.
		
		#More variables to store costs calculated in the scripts
		self.ipcomm = 0
		self.opcomm = 0
		self.ipcomm_uniq = 0
		self.opcomm_uniq = 0
		self.instrs = 0
		self.flops = 0
		self.iops = 0
	
###   end funcinfo   ###
	
class funcinst :
	''' Array to store data for a function instance. This is separated from other structs
	* to support a dynamic number of functioninfos for a function info item.
	* Chunks are allocated on demand, and deallocated at program termination.
	* This can also act as a linked list. This is needed because 
	* contiguous locations in the funcarray are not necessarily used. There may
	* be holes in between. Thus we need to track only the locations which are 
	* used from this list. 
	* Alternatively, an array could be used, but needs to be sized statically
	'''
	
	def __init__( self, caller, function_number, funcinst_number, num_calls, funcinfotable ) :
		
		#We need to be guaranteed that its corresponding funcinfo is already created. If it was not created, then this one will have funcinst_number to be -1.
		funcinfotemp = funcinfotable[function_number]
		self.consumedlist = {}
		self.consumerlist = {}
		self.function_number = function_number
		self.function_info = funcinfotemp #Store pointer to central info store of function
		self.funcinst_number = funcinst_number
		self.ipcomm_uniq = 0 #Not really useful, because this script is going to count all this based on granularity anyway
		self.opcomm_uniq = 0
		self.ipcomm = 0 #Not really useful, because this script is going to count all this based on granularity anyway
		self.opcomm = 0
		self.local_uniq = 0
		self.local = 0
		self.noprod_uniq = 0
		self.noprod = 0
		self.instrs = 0
		self.iops = 0
		self.flops = 0
		self.caller = caller #If caller is defined, then go ahead and put that in. (Otherwise it might error out when doing the first ever function)
		self.callees = []
		#More variables to store costs calculated in the scripts
		self.ipcomm_incl = 0 #For inclusive costs
		self.opcomm_incl = 0 #For inclusive costs
		self.ipcomm_incl_uniq = 0 #For inclusive costs
		self.opcomm_incl_uniq = 0 #For inclusive costs
		self.instrs_incl = 0
		self.flops_incl = 0
		self.iops_incl = 0
		self.num_calls = num_calls
		self.dependency_chains = []
		self.comp_comm_uniq = 0
		self.comp_comm = 0
		self.exec_cycles = 0
	
		if funcinfotemp != 0 :
			#self.funcinst_list_next = funcinfotemp.funcinst_list
			#self.funcinst_list_prev = 0
    
			#if funcinfotemp.funcinst_list
			#	funcinfotemp.funcinst_list.funcinst_list_prev = self
			#funcinfotemp.funcinst_list = self
    
			#self.funcinst_number = funcinfotemp.number_of_funcinsts
			#funcinfotemp.number_of_funcinsts++
			funcinfotemp.funcinsttable[funcinst_number] = self
		else :
			if funcinst_number != -1 :
				print "Uh Oh! funcinfotemp = 0, but funcinst_number != -1"
			#self.funcinst_list_next = 0
			#self.funcinst_list_prev = 0
		
###   end funcinst   ###
	
def readfromfile( filename, funcinfotable ) :

	caller_funcinst = None
	funcinstroot = None

	#Patterns for TREE DUMP
	patString = '^TREE DUMP'
	pattern1 = re.compile( patString )
	patString = '^(\d+), (\-*\d+), (\w+), (\d+)'
	pattern2 = re.compile( patString )
	patString = 'None'
	pattern3 = re.compile( patString )
	patString = '^END TREE DUMP'
	pattern4 = re.compile( patString )
	
	#Patterns for DATA DUMP
	patString = 'DATA DUMP'
	pattern5 = re.compile( patString )
	patString = '^(\d+)\s+(\-*\d+)\s+(.+)\*\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s*$' #This is to match the line where the function is defined. After this line will come the consumedlist
	pattern6 = re.compile( patString )
	patString = '^(\d+)\s+(\d+)\s+(.+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s*$' #This is for all lines in the consumedlist
	pattern7 = re.compile( patString )
	patString = '^(\d+)\s+(\d+)\s+(.+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s*$' #This is for capturing the parameters in the dependencylist
	pattern8 = re.compile( patString )
	
	#flags
	tree_flag = 0
	node_flag = 0
	star_flag = 0
	
	#tempvariables for data part
	funcinsttemp = 0
	local_uniq = 0
	local = 0
	noprod_uniq = 0
	noprod = 0
	
	fh = open( filename, "r" )
	
	for l in fh :
		l = l.strip() #Removes leading and ending whitespaces (we should have none in our output)

		# Here's the actual search
		if tree_flag :
			match2 = pattern2.search( l )
			match3 = pattern3.search( l )
			match4 = pattern4.search( l )
		elif node_flag :
			match6 = pattern6.search( l )
			match7 = pattern7.search( l )
			match8 = pattern8.search( l )
		else :
			match1 = pattern1.search( l )
			match5 = pattern5.search( l )
			#print "match1:", match1, "match5:", match5
			
		if tree_flag :
			#tree_flag += 1
			#print "tree_flag =", tree_flag
			if match2 :
				function_number = match2.group(1)
				funcinst_number = match2.group(2)
				children_flag = match2.group(3)
				num_calls = match2.group(4)	
				#Check if corresponding funcinfo is created and update it with whatever is necessary
				if function_number not in funcinfotable :
					if funcinst_number >= 0 :
						new_funcinfo = funcinfo( function_number ) #Here we do not have the fn_name yet, so leave it blank
						funcinfotable[function_number] = new_funcinfo
					else :
						funcinfotable[function_number] = 0
				
				#Then create funcinst as well.
				new_funcinst = funcinst( caller_funcinst, function_number, funcinst_number, num_calls, funcinfotable ) #This will also make sure the caller for the new funcinst points to the right funcinst object
				if caller_funcinst :#Make sure we only do the following when not examining the first node
					caller_funcinst.callees.append( new_funcinst ) #This will ensure that this new guy is added to the callees of the caller funcinst
				if not funcinstroot :
					funcinstroot = new_funcinst
					caller_funcinst = new_funcinst
				if children_flag == "True" :
					caller_funcinst = new_funcinst
				
			elif match3 : #None was encountered, so go back up one in the calltree
				#if caller_funcinst.caller :
				caller_funcinst = caller_funcinst.caller
				
			elif match4 :
				#If matches END TREE DUMP, then leave
				tree_flag = 0
				#fh.close() # THIS MUST BE REMOVED ONCE WE IMPLEMENT NODE_FLAG FUNCTIONALITY
				#return funcinstroot; # THIS MUST BE REMOVED ONCE WE IMPLEMENT NODE_FLAG FUNCTIONALITY
		
		elif node_flag :
			if match6 :
				#if star_flag :
					#Save state of previous funcinst
					
				#Figure out new funcinst, group(1) is the function number, group(2) is the funcinst number, group(3) is the name
				#The performance here can be improved drastically, because we are not using the information that the printing
				#of data will also be printed in the same deserialization order as was the calltree
				funcinfotemp = funcinfotable[match6.group(1)]
				funcinsttemp = funcinfotemp.funcinsttable[match6.group(2)]
				if not funcinfotemp.function_name :
					funcinfotemp.function_name = match6.group(3)
				funcinsttemp.instrs = int(match6.group(4))
				funcinsttemp.flops = int(match6.group(5))
				funcinsttemp.iops = int(match6.group(6))
				funcinsttemp.ipcomm_uniq = int(match6.group(7))
				funcinsttemp.ipcomm = int(match6.group(9))
				funcinsttemp.opcomm_uniq = int(match6.group(8))
				funcinsttemp.opcomm = int(match6.group(10))
				#star_flag = 1
				
			#elif match8 or match9 or match10 :
				#if match8 :
					
			#Clause to parse dependency list
			elif match8 :
				temp_coslist = funcinsttemp.consumedlist[(int(match8.group(1)), int(match8.group(2)))]
				temp_coslist.min_ipcomm_uniq = int(match8.group(4))
				temp_coslist.max_ipcomm_calls = int(match8.group(5))
				temp_coslist.tot_ipcomm_uniq = int(match8.group(6))
				temp_coslist.min_dep_calls = int(match8.group(7))
				temp_coslist.max_dep_calls = int(match8.group(8))
				temp_coslist.tot_dep_calls = int(match8.group(9))
					
			elif match7 :
				if "SELF" in match7.group(3) :
					funcinsttemp.local_uniq = int(match7.group(5))
					funcinsttemp.local = int(match7.group(7))
				elif "NO PRODUCER" in match7.group(3) :
					funcinsttemp.noprod_uniq = int(match7.group(5))
					funcinsttemp.noprod = int(match7.group(7))
				elif "NO CONSUMER" in match7.group(3) :
					funcinsttemp.nocons_uniq = int(match7.group(5))
					funcinsttemp.nocons = int(match7.group(7))
				else :
					consumed_fn = funcinfotable[match7.group(1)].funcinsttable[match7.group(2)]
					new_consumerfuncinfo = consumerfuncinfo( match7.group(1), match7.group(2), funcinsttemp, consumed_fn, match7.group(7), match7.group(5), match7.group(8), match7.group(6) )
					funcinsttemp.consumedlist[(int(match7.group(1)), int(match7.group(2)))] = new_consumerfuncinfo
					consumed_fn.consumerlist[(int(match7.group(1)), int(match7.group(2)))] = new_consumerfuncinfo
			
		else : # Matches to see which section is starting (whether its the tree structure or the info on the nodes). Both should be mutually exclusive
			if match1 :
				tree_flag = 1
			elif match5 :
				node_flag = 1
		
	
	#if star_flag
		
	
	fh.close()
	return funcinstroot;
		
		
def print_recurse_tree( funcinst ) :		
		
	#print "recursion happening"
	if funcinst.callees :
		children_flag = "True"
	else :
		children_flag = "False"
	print funcinst.function_number + ", " + funcinst.funcinst_number + ", " + children_flag
	
	for x in funcinst.callees :
		print_recurse_tree ( x )

	#If callees were present, the algorithm dictates that a "none" must be printed at the end
	if funcinst.callees :
		print "None"
				
def print_recurse_data( funcinst, funcinfotable ) :		
	
	#Added because when we run with --toggle-collect=main, some funcinst instances have their "function_info" variables as empty (0x0), because I suppose instrumentation does not happen for them, but funcinsts get created for them as their children may get created. We should actually be allowed to skip this and return without printing anything
	if funcinst.function_info == 0 :
		drw_funcname = "NOT COLLECTED"
	else :
		drw_funcname = funcinst.function_info.function_name
	caller = "*"
  
	print "%-20s %-20s %50s %20s %-20s %-20d %-20d %-20d %-20lu %-20lu %-20lu %-20lu" % (funcinst.function_number, funcinst.funcinst_number, drw_funcname, caller, funcinst.num_calls, funcinst.instrs, funcinst.flops, funcinst.iops, funcinst.ipcomm_uniq, funcinst.opcomm_uniq, funcinst.ipcomm, funcinst.opcomm)
  
	for consumerfuncinfotemp in funcinst.consumedlist.itervalues() :
		if funcinfotable[consumerfuncinfotemp.function_number] != 0 :
			drw_funcname = funcinfotable[consumerfuncinfotemp.function_number].function_name
		else :
			drw_funcname = "NOT COLLECTED"
		caller = ""
	
		print "%-20s %-20s %50s %20s %-20d %-20lu %-20lu %-20lu %-20lu" % (consumerfuncinfotemp.function_number, consumerfuncinfotemp.funcinst_number, drw_funcname, caller, 0, consumerfuncinfotemp.ipcomm_uniq, consumerfuncinfotemp.opcomm_uniq, consumerfuncinfotemp.ipcomm, consumerfuncinfotemp.opcomm)
	
	print ""
	
	for x in funcinst.callees :
		print_recurse_data ( x, funcinfotable )

def print_recurse_cost( funcinst, funcinfotable ) :		
	
	#Added because when we run with --toggle-collect=main, some funcinst instances have their "function_info" variables as empty (0x0), because I suppose instrumentation does not happen for them, but funcinsts get created for them as their children may get created. We should actually be allowed to skip this and return without printing anything
	if funcinst.function_info == 0 :
		drw_funcname = "NOT COLLECTED"
	else :
		drw_funcname = funcinst.function_info.function_name
	
	if (funcinst.ipcomm_incl_uniq + funcinst.opcomm_incl_uniq) != 0 :
		comp_comm_uniq = str(float(funcinst.flops_incl + funcinst.iops_incl)/float(funcinst.ipcomm_incl_uniq + funcinst.opcomm_incl_uniq))
	else :
		comp_comm_uniq = "MAX"
	if (funcinst.ipcomm_incl + funcinst.opcomm_incl) != 0 :
		comp_comm = (funcinst.flops_incl + funcinst.iops_incl)/float(funcinst.ipcomm_incl + funcinst.opcomm_incl)
	else :
		comp_comm = "MAX"
	#print "%-5d %-5d %50s %s %-15d %-10lu %-10lu %-10lu %-10lu %-10lu %-10lu" % (funcinst.function_number, funcinst.funcinst_number, drw_funcname, "*", funcinst.instrs_incl, funcinst.ipcomm_incl_uniq, funcinst.opcomm_incl_uniq, funcinst.local_uniq, funcinst.ipcomm_incl, funcinst.opcomm_incl, funcinst.local)
	print "%50s %s %-10s %-15d %-15d %-15d %-10lu %-10lu %-10lu %-10lu %-10lu %-10lu %-15s %-15s" % (drw_funcname, "*", funcinst.num_calls, funcinst.instrs_incl, funcinst.flops_incl, funcinst.iops_incl, funcinst.ipcomm_incl_uniq, funcinst.opcomm_incl_uniq, funcinst.local_uniq, funcinst.ipcomm_incl, funcinst.opcomm_incl, funcinst.local, comp_comm_uniq, comp_comm)
  
	#Start putting things into a list for plotting
	comm.append( funcinst.ipcomm_incl_uniq + funcinst.opcomm_incl_uniq )
	comp.append( funcinst.flops_incl + funcinst.iops_incl )
	label.append( funcinst.function_info.function_name )
  
	#Let us sort the list of callees by FLOP/IOPS? instructions before printing. That way, we'll not print the unimportant ones. We should eventually have a command line option specifying when to stop printing
	funcinst.callees.sort(key=lambda x: (x.flops_incl + x.iops_incl), reverse=True)
  
	if printcallees :
		for x in funcinst.callees :
			if x.function_info == 0 :
				drw_funcname = "NOT COLLECTED"
			else :
				drw_funcname = x.function_info.function_name
			if (x.ipcomm_incl_uniq + x.opcomm_incl_uniq) != 0 :
				comp_comm_uniq = str((x.flops_incl + x.iops_incl)/float(x.ipcomm_incl_uniq + x.opcomm_incl_uniq))
			else :
				comp_comm_uniq = "MAX"
			if (x.ipcomm_incl + x.opcomm_incl) != 0 :
				comp_comm = (x.flops_incl + x.iops_incl)/float(x.ipcomm_incl + x.opcomm_incl)
			else :
				comp_comm = "MAX"
			#print "%-5d %-5d %50s %s %-15d %-10lu %-10lu %-10lu %-10lu %-10lu %-10lu" % (x.function_number, x.funcinst_number, drw_funcname, "<", x.instrs_incl, x.ipcomm_incl_uniq, x.opcomm_incl_uniq, x.local_uniq, x.ipcomm_incl, x.opcomm_incl, x.local)
			print "%50s %s %-10s %-15d %-15d %-15d %-10lu %-10lu %-10lu %-10lu %-10lu %-10lu %-15s %-15s" % (drw_funcname, "<", x.num_calls, x.instrs_incl, x.flops_incl, x.iops_incl, x.ipcomm_incl_uniq, x.opcomm_incl_uniq, x.local_uniq, x.ipcomm_incl, x.opcomm_incl, x.local, comp_comm_uniq, comp_comm)
	
	print ""
	
	for x in funcinst.callees :
		#if x.instrs_incl/float(instrs_total) >= percentofinst/float(100) : #Print and remove the unnecessary functions
		if (x.flops_incl + x.iops_incl)/float(ops_total) >= percentofinst/float(100) : #Print and remove the unnecessary functions
			print_recurse_cost ( x, funcinfotable )

def print_only_bottom_old ( node, funcinfotable ) :
	
	if not node.callees :
		#print shit for this node
		print "%50s %s %-10s %-15d %-15d %-15d %-10lu %-10lu %-10lu %-10lu %-10lu %-10lu %-15f %-15f" % (node.function_info.function_name, "*", node.num_calls, node.instrs_incl, node.flops_incl, node.iops_incl, node.ipcomm_incl_uniq, node.opcomm_incl_uniq, node.local_uniq, node.ipcomm_incl, node.opcomm_incl, node.local, node.comp_comm_uniq, node.comp_comm)
  
		#Start putting things into a list for plotting
		comm.append( node.ipcomm_incl_uniq + node.opcomm_incl_uniq )
		comp.append( node.flops_incl + node.iops_incl )
		label.append( node.function_info.function_name )
	for x in node.callees :
		print_only_bottom ( x, funcinfotable )
		
def print_only_bottom ( bottom_list ) :
	
	bottom_list.sort(key=lambda x: (x.flops_incl + x.iops_incl), reverse=True)
	for node in bottom_list :
		if (node.flops_incl + node.iops_incl)/float(ops_total) >= percentofinst/float(100) :
			#Print and remove the unnecessary functions
			print "%50s %s %-10s %-15d %-15d %-15d %-10lu %-10lu %-10lu %-10lu %-10lu %-10lu %-15f %-15f" % (node.function_info.function_name, "*", node.num_calls, node.instrs_incl, node.flops_incl, node.iops_incl, node.ipcomm_incl_uniq, node.opcomm_incl_uniq, node.local_uniq, node.ipcomm_incl, node.opcomm_incl, node.local, node.comp_comm_uniq, node.comp_comm)
			
			#Start putting things into a list for plotting
			comm.append( node.ipcomm_incl_uniq + node.opcomm_incl_uniq )
			comp.append( node.flops_incl + node.iops_incl )
			label.append( node.function_info.function_name )
		
def check_callees_for_funcinst ( funcinst, consumerfuncinfo_ptr ) :
	'''This function simply checks for the funcinst described in consumerfuncinfo
	* against all the callees of funcinst. This is done to check if it its cost
	* should be included for the current caller.
	'''
	#Start by checking an immediate callee and then recursing into it's callees before moving on to the next immediate callee.
	for x in funcinst.callees :
		#Check if this callee is the one we are looking for.
		if (consumerfuncinfo_ptr.function_number == x.function_number and consumerfuncinfo_ptr.funcinst_number == x.funcinst_number) :
			return 1
		#else iterate over its callees
		foundflag = check_callees_for_funcinst ( x, consumerfuncinfo_ptr )
		if foundflag :
			return 1
	return 0
	
def check_callers_for_funcinst ( funcinst, consumerfuncinfo_ptr ) :
	'''This function simply checks for the funcinst described in consumerfuncinfo
	* against all the callers in the upper callchain of funcinst. This is done to check if * it its cost should be included for the current caller.
	'''
	#1. Start by checking the caller (Checking if a caller exists is done at the end)
	caller_funcinst = funcinst.caller
	if (consumerfuncinfo_ptr.function_number == caller_funcinst.function_number and consumerfuncinfo_ptr.funcinst_number == caller_funcinst.funcinst_number) :
		return 1
	
	#2. Check the caller's immediate callees and their callees
	for x in caller_funcinst.callees :
		#Skip the current funcinst in the callees of course
		if ( x == funcinst) :
			continue
		#Check if this callee is the one we are looking for.
		if (consumerfuncinfo_ptr.function_number == x.function_number and consumerfuncinfo_ptr.funcinst_number == x.funcinst_number) :
			consumerfuncinfo_ptr.callee_flag = 1
			return 1
		#else iterate over its callees
		foundflag = check_callees_for_funcinst ( x, consumerfuncinfo_ptr )
		if foundflag :
			consumerfuncinfo_ptr.callee_flag = 1
			return 1
	
	#3. Update costs in the current caller and then keep moving up
	caller_funcinst.ipcomm_incl += consumerfuncinfo_ptr.ipcomm
	caller_funcinst.opcomm_incl += consumerfuncinfo_ptr.opcomm
	caller_funcinst.ipcomm_incl_uniq += consumerfuncinfo_ptr.ipcomm_uniq
	caller_funcinst.opcomm_incl_uniq += consumerfuncinfo_ptr.opcomm_uniq
	if caller_funcinst.caller :
		#if !caller_funcinst.caller.caller
			#return 1
		#The above statements can be used to save some time as we don't need to process the topmost node at all. If we do not get any (uh-oh) errors, we can try this out.
		foundflag = check_callers_for_funcinst ( caller_funcinst, consumerfuncinfo_ptr )
	return foundflag
	
def calculate_clusive_costs( funcinst, funcinfotable ) : 
	'''This function calculates both inclusive and exclusive costs for each function in the * calltree
	'''
	for x in funcinst.callees :
		calculate_clusive_costs ( x, funcinfotable )
	
	#Alright no more callees, so now start accumulating costs
	#0. Do the inclusive instructions first
	funcinst.instrs_incl += funcinst.instrs
	funcinst.flops_incl += funcinst.flops
	funcinst.iops_incl += funcinst.iops
	if funcinst.caller :
		funcinst.caller.instrs_incl += funcinst.instrs_incl
		funcinst.caller.flops_incl += funcinst.flops_incl
		funcinst.caller.iops_incl += funcinst.iops_incl
	
	#1. print the cost for this function in its central store
	funcinst.function_info.ipcomm += funcinst.ipcomm
	funcinst.function_info.opcomm += funcinst.opcomm
	funcinst.function_info.ipcomm_uniq += funcinst.ipcomm_uniq
	funcinst.function_info.opcomm_uniq += funcinst.opcomm_uniq
	
	#2. Print the cost of this funcinst to all its callers by iterating over the consumed/consumer list and for each entry, check the entire calltree
	for consumerfuncinfo_ptr in funcinst.consumedlist.itervalues() :
		#1. Check callees
		foundflag = check_callees_for_funcinst ( funcinst, consumerfuncinfo_ptr ) #This call will not check the current funcinst variable as in that case consumerfuncinfotemp would have been SELF
		#2. If not found in step1, check callers and update costs as you go if not found in each caller's callee list
		if (foundflag == 0 and funcinst.caller) :
			funcinst.ipcomm_incl += consumerfuncinfo_ptr.ipcomm
			funcinst.opcomm_incl += consumerfuncinfo_ptr.opcomm
			funcinst.ipcomm_incl_uniq += consumerfuncinfo_ptr.ipcomm_uniq
			funcinst.opcomm_incl_uniq += consumerfuncinfo_ptr.opcomm_uniq
			if funcinst.caller :
				foundflag = check_callers_for_funcinst ( funcinst, consumerfuncinfo_ptr )
		if foundflag == 0 : #If still not found then something really bad has happened in populating the calltree
			print "Uh Oh! foundflag is zero for a certain consumerfuncinfo structure"
				

def trace_dependencies( funcinst, num) :
	'''This function recursively traces dependencies by recursively building a dependency chain upto MAX_DEPENDENCIES or if the same function is encountered again. NOT USED!'''
	
	trace_dependencies( x, 1)
				
def plot_data( funcinst, comm, comp, label, i ) :		
	
	#Iterate over only those callees that have a significant portions of the program. This will essentially go down to the bottom of the tree and start accumalating data from there
	for x in funcinst.callees :
		if (x.flops_incl + x.iops_incl)/float(ops_total) >= percentofinst/float(100) : #Print and remove the unnecessary functions
			plot_data ( x, comm, comp, label, i )
	
	#Start putting things into a list for plotting
	comm.append( funcinst.ipcomm_incl_uniq + funcinst.opcomm_incl_uniq )
	comp.append( funcinst.flops_incl + funcinst.iops_incl )
	label.append( funcinst.function_info.function_name )
	#i += 1;


def compare_callees_compcomm ( node, given_node ) :
	'''This function recursively goes down the calltree and checks if any callee's comp_comm_uniq ratio is higher than the given one. It will use the inclusive values'''
	#Iterate over callees and check their comp_comm_uniq
	foundflag = 0
	for x in node.callees :
		#1. If comp_comm of the current node has not been calculated (that is, it is zero), then calculate it and store it.
		if(x.comp_comm_uniq == 0) :
			if (x.ipcomm_incl_uniq + x.opcomm_incl_uniq) != 0 :
				x.comp_comm_uniq = (x.flops_incl + x.iops_incl)/float(x.ipcomm_incl_uniq + x.opcomm_incl_uniq)
			else :
				x.comp_comm_uniq = "MAX"
				#2. if x.comp_comm_uniq is "MAX" then there is an issue
				print "Node under main has inclusive communication costs as zero!"
				sys.exit(1)
		if(x.comp_comm == 0) :		
			if (x.ipcomm_incl + x.opcomm_incl) != 0 :
				x.comp_comm = (x.flops_incl + x.iops_incl)/float(x.ipcomm_incl + x.opcomm_incl)
			else :
				x.comp_comm = "MAX"
				#2. if x.comp_comm_uniq is "MAX" then there is an issue
				print "Node under main has inclusive communication costs as zero!"
				sys.exit(1)
		#3. Compare x.comp_comm_uniq costs and return 0 if something is found higher than node's comp_comm_uniq
		if x.comp_comm_uniq > node.comp_comm_uniq :
			return 0
	
	#Recurse down the calltree
	for x in node.callees :
		foundflag = compare_callees_compcomm ( x, given_node )
		if foundflag == 0 :
			return 0
		
	return 1
	
def reduce_tree_bygran ( node, bottom_list ) :
	'''This function recursively goes down the calltree and checks if all callees should be merged with a particular node, based on computation/communication. It will check the inclusive values'''
	#1. If comp_comm of the current node has not been calculated (that is, it is zero), then calculate it and store it.
	mergeflag = 0
	if(node.comp_comm_uniq == 0) :
		if (node.ipcomm_incl_uniq + node.opcomm_incl_uniq) != 0 :
			node.comp_comm_uniq = (node.flops_incl + node.iops_incl)/float(node.ipcomm_incl_uniq + node.opcomm_incl_uniq)
		else :
			node.comp_comm_uniq = "MAX"
			mergeflag = 1
	if(node.comp_comm == 0) :		
		if (node.ipcomm_incl + node.opcomm_incl) != 0 :
			node.comp_comm = (node.flops_incl + node.iops_incl)/float(node.ipcomm_incl + node.opcomm_incl)
		else :
			node.comp_comm = "MAX"
			mergeflag = 1
	#2. Iterate over calltree and see if any node has a higher comp/comm ratio.
	if mergeflag != 1 :
		mergeflag = compare_callees_compcomm( node, node )
	#3. If mergeflag is 1, remove all the callees of this guy and keep this as the last node in the tree so far
	if mergeflag == 1 :
		del node.callees[:] #Empty the list! A better way might be to add a flag marking it for deletion, but putting off the deletion itself for later.
	#4. Recurse down the tree now, to check the remaining nodes against their subtrees
	if not node.callees :
		bottom_list.append( node )
	for x in node.callees :
		reduce_tree_bygran ( x, bottom_list )
	
def search_for_main ( node ) :	

	for x in node.callees :
		if x.funcinst_number >= 0 :
			#Check if this callee is the one we are looking for.
			if "main" in x.function_info.function_name :
				if "dl_main" not in x.function_info.function_name :
					if "below main" not in x.function_info.function_name :
						return x #This is main!
	for x in node.callees :				
		#else iterate over its callees
		foundnode = search_for_main ( x )
		if foundnode != 0 :
			return foundnode
	return 0
				
def main() :

	global printcallees
	global percentofinst
	global instrs_total
	global ops_total
	global comm
	global comp
	global label
	
	# stick filename
	if len( sys.argv ) < 4 :  # no file name/no printcallees?/no percentage
	    # assume CLG_drwtest
		filename = "CLG_drwtest"
		printcallees = 0
		percentofinst = 0.01
		mode = 0
		usage()
	else :
		filename = sys.argv[1]
		if "yes" in sys.argv[2] :
			printcallees = 1
		elif "no" in sys.argv[2] :
			printcallees = 0
		else :
			print "Unknown print structure for callees! Continuing without printing callees"
			printcallees = 0
		percentofinst = float(sys.argv[3]) #Need to check validity of inputs
		if "modif" in sys.argv[4] :
			mode = 0
		elif "orig" in sys.argv[4] :
			mode = 1
		elif "both" in sys.argv[4] :
			mode = 2
		else :
			print "Unknown mode!"
			sys.exit(1)
	
	funcinfotable = {} #Declare the funcinfotable so that it can be passed into the constructor for a funcinst. It will do what is necessary
	funcinstroot = None
	bottom_list = []
	
	if mode == 1 :
		print "Mode 1 not implemented yet! Please use 0 or 2 for now"
		sys.exit(1)
	
	if mode == 0 or mode == 2 :
		funcinstroot = readfromfile( filename, funcinfotable )
		#print_recurse_tree( funcinstroot )
		#print_recurse_data ( funcinstroot, funcinfotable )
	
		#Now let us parse an original run of programs using Callgrind and (first call to generate it, then run callgrind_annotate and parse the output. Look for :function_name. If found, then thats our guy. Make an execution time estimation calculation for him. Per our original assumption, there should be no repeated names anyway. 
	
		calculate_clusive_costs ( funcinstroot, funcinfotable )
	
		#if mode == 2 :
			#Let us grab what is there in the callgrind output files as well
			
	
		#Search for main and reduce tree by granularity
		#i) Search for main from the root
		main_node = search_for_main ( funcinstroot )
		if main_node == 0 :
			print "Main node not found in calltree!"
			sys.exit(1)
		#ii) Reduce the number of nodes by granularity for each callee of main. Could modify this to include main
		for x in main_node.callees :
			reduce_tree_bygran ( x, bottom_list )
	
		print "%-50s %s %-10s %-15s %-15s %-15s %-10s %-10s %-10s %-10s %-10s %-10s %-15s %-15s" % ("Function name", " ", "Numcalls", "Instrs", "Flops", "Iops", "Ipcomm_uq", "Opcomm_uq", "Local_uq", "Ipcomm", "Opcomm", "Local", "Comp_Comm_uniq", "Comp_Comm")
		print ""
		instrs_total = main_node.instrs_incl
		ops_total = main_node.flops_incl + main_node.iops_incl
	
		##Now we can print, or plot or both
		#print_recurse_cost( funcinstroot, funcinfotable )
		#printing starting from main!
		if printcallees :
			print_recurse_cost( main_node, funcinfotable )
		else :
			#print_only_bottom_old ( main_node, funcinfotable )
			#print ""
			#print ""
			print_only_bottom ( bottom_list )
		
		plt.scatter( comm, comp, s=10, c="b", alpha=0.5, marker=r'o', label="Function" )
		plt.xlabel("Communication (bytes)")
		plt.ylabel("Computation (ops)")
		plt.legend(loc=2)
		plt.savefig('plot.pdf')
		plt.show()

main()
